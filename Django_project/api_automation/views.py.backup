"""
api_automation/views.py

Django REST Framework 视图定义
"""
from rest_framework import viewsets, status, permissions, views
from rest_framework.decorators import action
from rest_framework.response import Response
from django_filters.rest_framework import DjangoFilterBackend
from django.shortcuts import get_object_or_404
from django.db.models import Q, Count
from django.contrib.auth.models import User
from django.utils import timezone

from .models import (
    ApiProject, ApiCollection, ApiTestCase, ApiTestEnvironment,
    ApiTestExecution, ApiTestReport, ApiTestResult, ApiDataDriver
)
from .serializers import (
    ApiProjectSerializer, ApiProjectDetailSerializer,
    ApiCollectionSerializer, ApiCollectionDetailSerializer,
    ApiTestCaseSerializer, ApiTestCaseListSerializer,
    ApiTestEnvironmentSerializer, ApiTestEnvironmentDetailSerializer,
    ApiTestExecutionSerializer, ApiTestExecutionDetailSerializer,
    ApiTestResultSerializer, ApiTestReportSerializer,
    ApiDataDriverSerializer, UserSerializer
)


class ApiProjectViewSet(viewsets.ModelViewSet):
    """
    API项目视图集

    list:
    获取项目列表

    retrieve:
    获取项目详情

    create:
    创建新项目

    update:
    更新项目

    partial_update:
    部分更新项目

    destroy:
    删除项目（软删除）
    """
    serializer_class = ApiProjectSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['is_active']
    search_fields = ['name', 'description']
    ordering_fields = ['created_time', 'updated_time', 'name']
    ordering = ['-created_time']

    def get_queryset(self):
        """获取当前用户有权访问的项目列表"""
        user = self.request.user
        # 用户可以访问自己拥有的项目
        queryset = ApiProject.objects.filter(is_deleted=False)

        # 如果不是超级用户，只返回自己的项目
        if not user.is_superuser:
            queryset = queryset.filter(owner=user)

        return queryset

    def get_serializer_class(self):
        """根据action选择不同的序列化器"""
        if self.action == 'retrieve':
            return ApiProjectDetailSerializer
        return ApiProjectSerializer

    def perform_destroy(self, instance):
        """软删除项目"""
        instance.is_deleted = True
        instance.save()

    @action(detail=True, methods=['get'])
    def collections(self, request, pk=None):
        """获取项目的集合列表"""
        project = self.get_object()
        collections = project.api_collections.filter(is_deleted=False)
        serializer = ApiCollectionSerializer(collections, many=True)
        return Response(serializer.data)

    @action(detail=True, methods=['get'])
    def test_cases(self, request, pk=None):
        """获取项目的测试用例列表"""
        project = self.get_object()
        test_cases = project.test_cases.filter(is_deleted=False)

        # 支持按集合过滤
        collection_id = request.query_params.get('collection_id')
        if collection_id:
            test_cases = test_cases.filter(collection_id=collection_id)

        serializer = ApiTestCaseListSerializer(test_cases, many=True)
        return Response(serializer.data)

    @action(detail=True, methods=['post'])
    def clone(self, request, pk=None):
        """克隆项目"""
        project = self.get_object()
        new_name = request.data.get('name', f"{project.name}_副本")

        # 创建新项目
        new_project = ApiProject.objects.create(
            name=new_name,
            description=f"克隆自项目: {project.name}",
            owner=request.user
        )

        # TODO: 克隆集合和测试用例

        serializer = self.get_serializer(new_project)
        return Response(serializer.data, status=status.HTTP_201_CREATED)


class ApiCollectionViewSet(viewsets.ModelViewSet):
    """
    API集合视图集

    list:
    获取集合列表

    retrieve:
    获取集合详情

    create:
    创建新集合

    update:
    更新集合

    partial_update:
    部分更新集合

    destroy:
    删除集合（软删除）
    """
    serializer_class = ApiCollectionSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['project']
    search_fields = ['name', 'description']
    ordering_fields = ['created_time', 'updated_time', 'name']
    ordering = ['-created_time']

    def get_queryset(self):
        """获取当前用户有权访问的集合列表"""
        user = self.request.user
        queryset = ApiCollection.objects.filter(is_deleted=False)

        # 根据项目权限过滤
        if not user.is_superuser:
            # 只返回用户拥有项目的集合
            queryset = queryset.filter(project__owner=user)

        # 支持按项目过滤
        project_id = self.request.query_params.get('project_id')
        if project_id:
            queryset = queryset.filter(project_id=project_id)

        return queryset

    def get_serializer_class(self):
        """根据action选择不同的序列化器"""
        if self.action == 'retrieve':
            return ApiCollectionDetailSerializer
        return ApiCollectionSerializer

    def perform_destroy(self, instance):
        """软删除集合"""
        instance.is_deleted = True
        instance.save()

    @action(detail=True, methods=['get'])
    def test_cases(self, request, pk=None):
        """获取集合的测试用例列表"""
        collection = self.get_object()
        test_cases = collection.test_cases.filter(is_deleted=False)
        serializer = ApiTestCaseListSerializer(test_cases, many=True)
        return Response(serializer.data)


class ApiTestCaseViewSet(viewsets.ModelViewSet):
    """
    API测试用例视图集

    list:
    获取测试用例列表

    retrieve:
    获取测试用例详情

    create:
    创建新测试用例

    update:
    更新测试用例

    partial_update:
    部分更新测试用例

    destroy:
    删除测试用例（软删除）
    """
    serializer_class = ApiTestCaseSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['project', 'collection', 'method']
    search_fields = ['name', 'description', 'url']
    ordering_fields = ['created_time', 'updated_time', 'name']
    ordering = ['-created_time']

    def get_queryset(self):
        """获取当前用户有权访问的测试用例列表"""
        user = self.request.user
        queryset = ApiTestCase.objects.filter(is_deleted=False)

        # 根据项目权限过滤
        if not user.is_superuser:
            # 只返回用户拥有项目的测试用例
            queryset = queryset.filter(project__owner=user)

        # 支持多种过滤方式
        project_id = self.request.query_params.get('project_id')
        if project_id:
            queryset = queryset.filter(project_id=project_id)

        collection_id = self.request.query_params.get('collection_id')
        if collection_id:
            queryset = queryset.filter(collection_id=collection_id)

        return queryset

    def get_serializer_class(self):
        """根据action选择不同的序列化器"""
        if self.action == 'list':
            return ApiTestCaseListSerializer
        return ApiTestCaseSerializer

    def perform_destroy(self, instance):
        """软删除测试用例"""
        instance.is_deleted = True
        instance.save()

    @action(detail=True, methods=['post'])
    def clone(self, request, pk=None):
        """克隆测试用例"""
        test_case = self.get_object()
        new_name = request.data.get('name', f"{test_case.name}_副本")

        # 创建新的测试用例
        new_test_case = ApiTestCase.objects.create(
            name=new_name,
            description=test_case.description,
            project=test_case.project,
            collection=test_case.collection,
            method=test_case.method,
            url=test_case.url,
            headers=test_case.headers,
            params=test_case.params,
            body=test_case.body,
            created_by=request.user
        )

        serializer = self.get_serializer(new_test_case)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    @action(detail=True, methods=['post'])
    def run_test(self, request, pk=None):
        """执行单个测试用例"""
        test_case = self.get_object()
        environment_id = request.data.get('environment_id')

        # 获取测试环境
        try:
            if environment_id:
                environment = ApiTestEnvironment.objects.get(id=environment_id, project=test_case.project)
            else:
                # 获取默认环境
                environment = ApiTestEnvironment.objects.filter(
                    project=test_case.project,
                    is_default=True,
                    is_deleted=False
                ).first()
                if not environment:
                    return Response({
                        'error': '请指定测试环境或配置默认环境'
                    }, status=400)
        except ApiTestEnvironment.DoesNotExist:
            return Response({
                'error': '指定的测试环境不存在'
            }, status=404)

        # 创建临时执行记录用于单个测试
        from .services.http_executor import HttpExecutor
        from .services.assertion_engine import AssertionEngine

        start_time = timezone.now()

        try:
            # 合并请求头
            request_headers = {}
            request_headers.update(environment.global_headers or {})
            request_headers.update(test_case.headers or {})

            # 创建HTTP执行器
            http_executor = HttpExecutor(timeout=30)

            # 执行HTTP请求
            http_response = http_executor.execute_request(
                method=test_case.method,
                url=test_case.url,
                base_url=environment.base_url,
                headers=request_headers,
                params=test_case.params,
                body=test_case.body,
                global_variables=environment.global_variables or {}
            )

            # 创建断言引擎
            assertion_engine = AssertionEngine()

            # 获取断言配置
            assertions = test_case.tests if test_case.tests else assertion_engine.get_default_assertions()

            # 执行断言
            assertion_result_objects, assertions_passed = assertion_engine.evaluate_assertions(
                assertions=assertions,
                http_response=http_response,
                response_body=http_response.body
            )

            # 转换断言结果为字典格式
            assertion_results = [result.to_dict() for result in assertion_result_objects]

            # 确定测试状态
            if http_response.error:
                status = 'ERROR'
                error_message = http_response.error
            elif not assertions_passed:
                status = 'FAILED'
                error_message = None
            else:
                status = 'PASSED'
                error_message = None

            # 关闭HTTP执行器
            http_executor.close()

            # 返回测试结果
            return Response({
                'status': status,
                'test_case': {
                    'id': test_case.id,
                    'name': test_case.name,
                    'method': test_case.method,
                    'url': test_case.url
                },
                'environment': {
                    'id': environment.id,
                    'name': environment.name,
                    'base_url': environment.base_url
                },
                'request': {
                    'url': http_response.raw_response.url if http_response.raw_response else test_case.url,
                    'method': test_case.method,
                    'headers': request_headers,
                    'body': test_case.body,
                    'params': test_case.params
                },
                'response': {
                    'status_code': http_response.status_code,
                    'headers': dict(http_response.headers) if http_response.headers else {},
                    'body': http_response.body if http_response.body else {},
                    'response_time': int(http_response.response_time) if http_response.response_time else None,
                    'size': http_response.body_size if http_response.body_size else None
                },
                'assertions': assertion_results,
                'assertions_passed': assertions_passed,
                'error_message': error_message,
                'start_time': start_time.isoformat(),
                'end_time': timezone.now().isoformat(),
                'duration': int((timezone.now() - start_time).total_seconds() * 1000)
            })

        except Exception as e:
            return Response({
                'status': 'ERROR',
                'error_message': str(e),
                'test_case': {
                    'id': test_case.id,
                    'name': test_case.name,
                    'method': test_case.method,
                    'url': test_case.url
                },
                'start_time': start_time.isoformat(),
                'end_time': timezone.now().isoformat()
            }, status=500)

    @action(detail=False, methods=['get'])
    def statistics(self, request):
        """获取测试用例统计信息"""
        user = request.user
        queryset = ApiTestCase.objects.filter(is_deleted=False)

        if not user.is_superuser:
            queryset = queryset.filter(project__owner=user)

        # 按方法统计
        method_stats = queryset.values('method').annotate(count=Count('id'))

        # 按项目统计
        project_stats = queryset.values('project__name').annotate(count=Count('id'))

        # 总数
        total_count = queryset.count()

        data = {
            'total_count': total_count,
            'method_distribution': list(method_stats),
            'project_distribution': list(project_stats)
        }

        return Response(data)

class CurrentUserView(views.APIView):
    """
    获取当前用户信息
    """
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        serializer = UserSerializer(request.user)
        return Response(serializer.data)


class ApiTestEnvironmentViewSet(viewsets.ModelViewSet):
    """
    API测试环境视图集
    """
    serializer_class = ApiTestEnvironmentSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['project', 'is_active', 'is_default']
    search_fields = ['name', 'description']
    ordering_fields = ['created_time', 'updated_time', 'name']

    def get_queryset(self):
        """获取查询集"""
        user = self.request.user
        if user.is_superuser:
            return ApiTestEnvironment.objects.filter(is_deleted=False)
        else:
            return ApiTestEnvironment.objects.filter(
                Q(project__owner=user) | Q(project__is_active=True),
                is_deleted=False
            ).distinct()

    def get_serializer_class(self):
        """根据操作返回不同的序列化器"""
        if self.action == 'retrieve':
            return ApiTestEnvironmentDetailSerializer
        return ApiTestEnvironmentSerializer

    def perform_destroy(self, instance):
        """软删除"""
        instance.is_deleted = True
        instance.save()

    @action(detail=True, methods=['post'])
    def set_default(self, request, pk=None):
        """设置为默认环境"""
        environment = self.get_object()

        # 取消该项目的其他默认环境
        ApiTestEnvironment.objects.filter(
            project=environment.project,
            is_default=True,
            is_deleted=False
        ).update(is_default=False)

        # 设置当前环境为默认
        environment.is_default = True
        environment.save()

        return Response({'message': f'已将 {environment.name} 设置为默认环境'})

    @action(detail=True, methods=['get'])
    def test_connection(self, request, pk=None):
        """测试环境连接"""
        environment = self.get_object()

        try:
            # 这里可以添加实际的连接测试逻辑
            # 比如发送一个简单的请求到base_url
            import requests
            response = requests.get(f"{environment.base_url.rstrip('/')}/", timeout=10)

            if response.status_code < 400:
                return Response({
                    'status': 'success',
                    'message': '连接成功',
                    'response_time': response.elapsed.total_seconds() * 1000
                })
            else:
                return Response({
                    'status': 'error',
                    'message': f'连接失败，状态码: {response.status_code}'
                }, status=400)
        except Exception as e:
            return Response({
                'status': 'error',
                'message': f'连接失败: {str(e)}'
            }, status=400)


class ApiTestExecutionViewSet(viewsets.ModelViewSet):
    """
    API测试执行视图集
    """
    serializer_class = ApiTestExecutionSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['project', 'environment', 'status']
    search_fields = ['name', 'description']
    ordering_fields = ['created_time', 'start_time', 'name']

    def get_queryset(self):
        """获取查询集"""
        user = self.request.user
        if user.is_superuser:
            return ApiTestExecution.objects.filter(is_deleted=False)
        else:
            return ApiTestExecution.objects.filter(
                Q(project__owner=user) | Q(project__is_active=True),
                is_deleted=False
            ).distinct()

    def get_serializer_class(self):
        """根据操作返回不同的序列化器"""
        if self.action == 'retrieve':
            return ApiTestExecutionDetailSerializer
        return ApiTestExecutionSerializer

    def perform_destroy(self, instance):
        """软删除"""
        instance.is_deleted = True
        instance.save()

    @action(detail=True, methods=['post'])
    def execute(self, request, pk=None):
        """执行测试"""
        execution = self.get_object()

        if execution.status != 'PENDING':
            return Response({
                'error': '只能执行待执行状态的测试'
            }, status=400)

        # 更新执行状态
        execution.status = 'RUNNING'
        execution.start_time = timezone.now()
        execution.save()

        try:
            # 这里应该添加实际的测试执行逻辑
            # 包括：根据环境配置执行测试用例，生成测试结果等

            # 模拟执行过程
            import time

            test_cases = ApiTestCase.objects.filter(
                id__in=execution.test_cases,
                is_deleted=False
            )

            execution.total_count = test_cases.count()
            execution.passed_count = 0
            execution.failed_count = 0
            execution.skipped_count = 0

            # 执行每个测试用例
            for test_case in test_cases:
                result = self._execute_single_test_case(test_case, execution)
                if result == 'PASSED':
                    execution.passed_count += 1
                elif result == 'FAILED':
                    execution.failed_count += 1
                else:
                    execution.skipped_count += 1

            execution.status = 'COMPLETED'
            execution.end_time = timezone.now()
            execution.duration = int((execution.end_time - execution.start_time).total_seconds())
            execution.save()

            # 生成测试报告
            self._generate_test_report(execution)

            return Response({
                'message': '测试执行完成',
                'execution_id': execution.id,
                'total_count': execution.total_count,
                'passed_count': execution.passed_count,
                'failed_count': execution.failed_count,
                'duration': execution.duration
            })

        except Exception as e:
            execution.status = 'FAILED'
            execution.end_time = timezone.now()
            execution.save()

            return Response({
                'error': f'测试执行失败: {str(e)}'
            }, status=500)

    def _execute_single_test_case(self, test_case, execution):
        """执行单个测试用例"""
        from .services.http_executor import HttpExecutor
        from .services.assertion_engine import AssertionEngine
        import time

        start_time = timezone.now()
        status = 'ERROR'
        error_message = None
        assertion_results = []

        try:
            # 获取测试环境配置
            environment = execution.environment
            global_headers = environment.global_headers if environment else {}
            global_variables = environment.global_variables if environment else {}
            base_url = environment.base_url if environment else ""

            # 合并请求头
            request_headers = {}
            request_headers.update(global_headers)
            request_headers.update(test_case.headers or {})

            # 创建HTTP执行器
            http_executor = HttpExecutor(timeout=30)

            # 执行HTTP请求
            http_response = http_executor.execute_request(
                method=test_case.method,
                url=test_case.url,
                base_url=base_url,
                headers=request_headers,
                params=test_case.params,
                body=test_case.body,
                global_variables=global_variables
            )

            # 创建断言引擎
            assertion_engine = AssertionEngine()

            # 获取断言配置，如果没有则使用默认断言
            assertions = test_case.tests if test_case.tests else assertion_engine.get_default_assertions()

            # 执行断言
            assertion_result_objects, assertions_passed = assertion_engine.evaluate_assertions(
                assertions=assertions,
                http_response=http_response,
                response_body=http_response.body
            )

            # 转换断言结果为字典格式
            assertion_results = [result.to_dict() for result in assertion_result_objects]

            # 确定测试状态
            if http_response.error:
                status = 'ERROR'
                error_message = http_response.error
            elif not assertions_passed:
                status = 'FAILED'
            else:
                status = 'PASSED'

            # 创建测试结果记录
            ApiTestResult.objects.create(
                execution=execution,
                test_case=test_case,
                status=status,
                response_status=http_response.status_code if http_response.status_code else None,
                response_time=int(http_response.response_time) if http_response.response_time else None,
                response_size=http_response.body_size if http_response.body_size else None,
                request_url=http_response.raw_response.url if http_response.raw_response else test_case.url,
                request_method=test_case.method,
                request_headers=request_headers,
                request_body=test_case.body,
                response_headers=dict(http_response.headers) if http_response.headers else {},
                response_body=http_response.body if http_response.body else {},
                assertion_results=assertion_results,
                error_message=error_message,
                start_time=start_time,
                end_time=timezone.now(),
                duration=int((timezone.now() - start_time).total_seconds() * 1000)
            )

            # 关闭HTTP执行器
            http_executor.close()

        except Exception as e:
            status = 'ERROR'
            error_message = str(e)

            # 创建错误结果记录
            ApiTestResult.objects.create(
                execution=execution,
                test_case=test_case,
                status=status,
                response_status=None,
                response_time=None,
                response_size=None,
                request_url=test_case.url,
                request_method=test_case.method,
                request_headers=test_case.headers or {},
                request_body=test_case.body or {},
                response_headers={},
                response_body={},
                assertion_results=[],
                error_message=error_message,
                start_time=start_time,
                end_time=timezone.now(),
                duration=int((timezone.now() - start_time).total_seconds() * 1000)
            )

        return status

    def _generate_test_report(self, execution):
        """生成测试报告"""
        from django.utils import timezone

        # 获取测试结果
        test_results = ApiTestResult.objects.filter(execution=execution)

        # 生成摘要数据
        summary = {
            'total': execution.total_count,
            'passed': execution.passed_count,
            'failed': execution.failed_count,
            'skipped': execution.skipped_count,
            'pass_rate': round(execution.passed_count / execution.total_count * 100, 2) if execution.total_count > 0 else 0,
            'duration': execution.duration,
            'start_time': execution.start_time.isoformat() if execution.start_time else None,
            'end_time': execution.end_time.isoformat() if execution.end_time else None
        }

        # 生成图表数据
        charts_data = {
            'status_pie': {
                'labels': ['通过', '失败', '跳过'],
                'data': [execution.passed_count, execution.failed_count, execution.skipped_count]
            },
            'response_time': {
                'labels': [result.test_case.name for result in test_results],
                'data': [result.response_time for result in test_results if result.response_time]
            }
        }

        # 创建测试报告
        ApiTestReport.objects.create(
            execution=execution,
            name=f'{execution.name} - 测试报告',
            summary=summary,
            test_results=list(test_results.values()),
            charts_data=charts_data
        )

    @action(detail=True, methods=['post'])
    def cancel(self, request, pk=None):
        """取消测试执行"""
        execution = self.get_object()

        if execution.status not in ['PENDING', 'RUNNING']:
            return Response({
                'error': '只能取消待执行或执行中的测试'
            }, status=400)

        execution.status = 'CANCELLED'
        execution.end_time = timezone.now()
        execution.save()

        return Response({'message': '测试执行已取消'})

    @action(detail=False, methods=['get'])
    def statistics(self, request):
        """获取执行统计信息"""
        queryset = self.get_queryset()
        user = request.user

        if not user.is_superuser:
            queryset = queryset.filter(project__owner=user)

        # 按状态统计
        status_stats = queryset.values('status').annotate(count=Count('id'))

        # 按项目统计
        project_stats = queryset.values('project__name').annotate(count=Count('id'))

        # 总数
        total_count = queryset.count()

        data = {
            'total_count': total_count,
            'status_distribution': list(status_stats),
            'project_distribution': list(project_stats)
        }

        return Response(data)


class ApiTestReportViewSet(viewsets.ReadOnlyModelViewSet):
    """
    API测试报告视图集（只读）
    """
    serializer_class = ApiTestReportSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['execution']
    search_fields = ['name']
    ordering_fields = ['created_time', 'name']

    def get_queryset(self):
        """获取查询集"""
        user = self.request.user
        if user.is_superuser:
            return ApiTestReport.objects.all()
        else:
            return ApiTestReport.objects.filter(
                Q(execution__project__owner=user) | Q(execution__project__is_active=True)
            ).distinct()

    @action(detail=True, methods=['get'])
    def export(self, request, pk=None):
        """导出测试报告"""
        report = self.get_object()

        # 这里可以添加导出逻辑，比如导出为PDF、Excel等格式
        return Response({
            'message': f'报告 {report.name} 导出功能待实现',
            'report_id': report.id
        })


class ApiDataDriverViewSet(viewsets.ModelViewSet):
    """
    API数据驱动视图集
    """
    serializer_class = ApiDataDriverSerializer
    permission_classes = [permissions.IsAuthenticated]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['project', 'test_case', 'data_type', 'is_active']
    search_fields = ['name', 'description']
    ordering_fields = ['created_time', 'updated_time', 'name']

    def get_queryset(self):
        """获取查询集"""
        user = self.request.user
        if user.is_superuser:
            return ApiDataDriver.objects.filter(is_deleted=False)
        else:
            return ApiDataDriver.objects.filter(
                Q(project__owner=user) | Q(project__is_active=True),
                is_deleted=False
            ).distinct()

    def perform_destroy(self, instance):
        """软删除"""
        instance.is_deleted = True
        instance.save()

    @action(detail=True, methods=['post'])
    def preview_data(self, request, pk=None):
        """预览数据内容"""
        data_driver = self.get_object()

        return Response({
            'data_type': data_driver.data_type,
            'data_content': data_driver.data_content,
            'variable_mapping': data_driver.variable_mapping,
            'sample_data': data_driver.data_content[:3] if data_driver.data_content else []
        })

    @action(detail=False, methods=['post'])
    def import_data(self, request):
        """导入数据"""
        # 这里可以添加数据导入逻辑
        return Response({
            'message': '数据导入功能待实现'
        })
